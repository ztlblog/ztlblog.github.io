<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: php | Blog like hacke]]></title>
  <link href="http://ztlblog.github.io/blog/categories/php/atom.xml" rel="self"/>
  <link href="http://ztlblog.github.io/"/>
  <updated>2015-08-12T14:02:42+08:00</updated>
  <id>http://ztlblog.github.io/</id>
  <author>
    <name><![CDATA[ztl]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[php之缓冲区]]></title>
    <link href="http://ztlblog.github.io/blog/2015/07/23/php005/"/>
    <updated>2015-07-23T13:24:24+08:00</updated>
    <id>http://ztlblog.github.io/blog/2015/07/23/php005</id>
    <content type="html"><![CDATA[<p><strong>ob_flush 与 flush 区别</strong></p>

<pre><code>ob_flush:是把数据从php的缓冲中释放出来
flush:是把不在缓冲中的或者说是被释放出来的数据发送到浏览器
所以当缓冲存在的时候，我们必须ob_flush和flush同时使用.
</code></pre>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[php经典排序算法]]></title>
    <link href="http://ztlblog.github.io/blog/2015/06/19/php002/"/>
    <updated>2015-06-19T10:25:07+08:00</updated>
    <id>http://ztlblog.github.io/blog/2015/06/19/php002</id>
    <content type="html"><![CDATA[<p>{% codeblock 冒泡排序 %}
function bubble_sort($arr)
{
    $len = count($arr);
    for($i=0;$i&lt;$len;$i++)
    {
        for($j=1;$j&lt;$len-$i;$j++)
        {
            if($arr[$j]>$arr[$j+1])
            {
                $temp      = $arr[$j];
                $arr[$j]   = $arr[$j+1];
                $arr[$j+1] = $temp;
            }
        }
    }
    return $arr;
}
{% endcodeblock %}</p>

<p>{% codeblock 快速排序 %}
function quite_sort($arr)
{
    $len = count($arr);
    if($len &lt;= 1)
    {
        return $arr;  <br/>
    }
    $key = $arr[0];
    $left_arr = array();
    $right_arr = array();
    for($i=1;$i&lt;$len;$i++)
    {
        if($key > $arr[$i])
        {
            $left_arr[] = $arr[$i];
        }else
        {
            $right_arr[] = $arr[$i];
        }
    }</p>

<pre><code>$left_arr = quite_sort($left_arr);
$right_arr = quite_sort($right_arr);

return array_merge($left_arr,array($key),$right_arr);
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock 选择排序 %}
思路：每次选择一个相应的元素，然后将其放到指定的位置
function select_sort($arr)
{
    $len = count($arr);
    for($i=0;$i&lt;$len;$i++)
    {
        $minInx = $i;
        for($j=$i;$j&lt;$len;$j++)
        {
            if($arr[$minInx] > $arr[$j])
            {
                $minInx = $j;
            }
        }</p>

<pre><code>    if($minInx != $i)
    {
        $temp     = $arr[$i];
        $arr[$i]  = $arr[$minInx];
        $arr[$minInx] = $temp;
    }

}
return $arr;
</code></pre>

<p>}
{% endcodeblock %}</p>

<p>{% codeblock 插入排序 %}
思路：将要排序的元素插入到已经假定排序好的数组的指定位置
function insert_sort($arr)
{
    $len = count($arr);
    for($i=1;$i&lt;$len;$i++)
    {
        $temp = $arr[$i];
        for($j=$i-1;$j>=0;$j&ndash;)
        {
            if($temp &lt; $arr[$j])
            {
                $arr[$j+1] = $arr[$j];
                $arr[$j]   = $temp;
            } <br/>
        }else
        {
            break;
        }
    }
    return $arr;
}
{% endcodeblock %}</p>

<p>{% codeblock 堆排序 %}
function margeArr($arr1,$arr2)
{
    $a_1 = 0;
    $b_1 = 0;
    $arrA = count($arr1);
    $arrB = count($arr2);</p>

<pre><code>while($a_1 &lt; $arrA &amp;&amp; $b_1 &lt; $arrB)
{
    if($arr1[$a_1] &lt; $arr2[$b_1])
    {
        $arrC[] = $arr1[$a_1++];
    }else
    {
        $arrC[] = $arr[$b_1++];
    }
}

while($a_1 &lt; $arrA)
{
    $arrC[] = $arr1[$a_1++];
}

while($b_1 &lt; $arrB)
{
    $arrC[] = $arr2[$b_1++];
}

return $arrC;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[秒杀系统架构优化思路]]></title>
    <link href="http://ztlblog.github.io/blog/2015/06/17/php001/"/>
    <updated>2015-06-17T11:39:18+08:00</updated>
    <id>http://ztlblog.github.io/blog/2015/06/17/php001</id>
    <content type="html"><![CDATA[<h2>秒杀系统挂的主要原因（数据读写锁冲突严重）</h2>

<p>{% codeblock 常见架构 %}
浏览器->站点->服务->数据
浏览器端最上层，会执行一些js
站点层，会访问后端数据，拼html页面返回给浏览器
服务层，会向上游屏蔽数据细节
数据层，最终的库存是存在这里的
{% endcodeblock %}</p>

<h2>优化细节</h2>

<p>{% codeblock 浏览器层请求拦截 %}
作为用户点击'查询'按钮之后，由于系统太卡页面打不开，一般用户会继续点，这样会给服务器带来更大的负载
产品层面： 用户点击'查询'或'购票'后，按钮变灰，禁止用户重复提交请求
js层面： 限制用户在x秒之后只能提交一次请求
{% endcodeblock %}</p>

<p>{% codeblock 站点层请求拦截 %}
产品层面只能拦住小白用户，高端程序员根本不吃这一套，写一个for循环，直接调用你的后端的http请求
解决办法：
同一个uid，限制访问频率，做页面缓存，x秒达到站点层的请求，均返回同一个页面
同一个item的查询，做页面缓存，x秒内到达站点的请求，均返回同一个页面
{% endcodeblock %}</p>

<p>{% codeblock 服务层请求拦截 %}
站点层的请求拦截，只能拦截程序员，高级黑客可以通过肉鸡注入，这下uid的限制就不行了
解决办法：
对于写请求，做请求队列，每次只透过有限的写请求去数据层，如果均成功再放下一批，如果库存不够则队列里面的写请求全部返回'已售完'
对于读请求，可以做缓存(memcache,redis&hellip;)
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
